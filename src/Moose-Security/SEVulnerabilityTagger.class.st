"
I am an abstract class to represent a tagger of vulnerability.

I should be configured with a block to find the entities to tag in a model and also configured with a tag name to tag those entities. I can then be applied on a model using `#applyOn:`.

It is possibile to tag all vulnerable entities of a model executing:

```st
SEVulnerabilityTagger tagAllVulnerabilitiesOf: aMooseModel
```

You can visualize the result of the tagging directly using:

```st
SEVulnerabilityTagger tagAndVisualize: aModel
```

You can also have the visualization centered on the tags instead of the project by doing:

```
SEVulnerabilityTagger tagAndVisualizeTags: aModel
```

You can remove all generated tags using:

```st
SEVulnerabilityTagger removeAllGeneratedTagsOf: aModel
```

It is also possible to tag only one kind of vulnerable entites executing:

```st
SEVulnerabilityTagger transformerClassTagger applyOn: aMooseModel
```
"
Class {
	#name : 'SEVulnerabilityTagger',
	#superclass : 'Object',
	#instVars : [
		'queryBlock'
	],
	#classInstVars : [
		'assocChanges'
	],
	#category : 'Moose-Security-Taggers',
	#package : 'Moose-Security',
	#tag : 'Taggers'
}

{ #category : 'meta-programming' }
SEVulnerabilityTagger class >> generateColorMethods [
	"I generate methods in my subclasses to define the color of their tag using the color wheel."

	<script>
	| classes colors |
	classes := self allSubclasses.
	colors := Color wheel: classes size.
	classes doWithIndex: [ :class :index |
		class class
			compile: 'tagColor
	"Method generated by SEVulnerabilityTagger class>>#generateColorMethods"

	^ ' , (colors at: index) storeString
			classified: 'accessing' ]
]

{ #category : 'accessing' }
SEVulnerabilityTagger class >> removeAllGeneratedTagsOf: aModel [

	self allSubclasses
		collect: [ :class | class tagName ]
		thenDo: [ :tagName |
			aModel allTags
				detect: [ :tag | tag name = tagName ]
				ifFound: [ :tag | tag remove ] ]
]

{ #category : 'tagging' }
SEVulnerabilityTagger class >> tagAllVulnerabilitiesOf: aModel [

	self vulnerabilityTaggers do: [ :tagger | tagger applyOn: aModel ]
]

{ #category : 'accessing' }
SEVulnerabilityTagger class >> tagAndVisualize: aMooseModel [

	self tagAndVisualize: aMooseModel propagating: [ (aMooseModel allUsing: FamixTNamedEntity) reject: #isStub ]
]

{ #category : 'accessing' }
SEVulnerabilityTagger class >> tagAndVisualize: aMooseModel propagating: aBlock [

	| browser |
	self tagAllVulnerabilitiesOf: aMooseModel.

	aBlock value miPropagate.

	browser := MiArchitecturalMapBrowser open.
	browser beFrozen.
	browser window title: browser window title , ' [' , aMooseModel name , ']'
]

{ #category : 'accessing' }
SEVulnerabilityTagger class >> tagAndVisualizeTags: aMooseModel [

	self tagAndVisualize: aMooseModel propagating: [ aMooseModel allTags ]
]

{ #category : 'accessing' }
SEVulnerabilityTagger class >> tagColor [
	"If you end up here you can just execute SEVulnerabilityTagger class>>#generateColorMethods"

	self subclassResponsibility
]

{ #category : 'accessing' }
SEVulnerabilityTagger class >> tagName [

	self subclassResponsibility
]

{ #category : 'instance creation' }
SEVulnerabilityTagger class >> tagResultOf: aBlock [

	^ self new
		  queryBlock: aBlock;
		  yourself
]

{ #category : 'accessing' }
SEVulnerabilityTagger class >> vulnerabilityTaggers [

	| taggers |
	taggers := OrderedCollection new.
	((self class withAllSubclasses flatCollect: #methods) select: [
		 :method |
		 method pragmas anySatisfy: [ :pragma |
			 pragma selector = #cautionTagger ] ]) do: [ :method |
		method methodClass soleInstance
			perform: method selector
			with: taggers ].
	^ taggers
]

{ #category : 'instance creation' }
SEVulnerabilityTagger >> applyOn: aModel [

	(self queryBlock cull: aModel cull: self) ifNotEmpty: [ :entities |
		| tag |
		tag := self tagToUseFrom: aModel.
		entities do: [ :e | e tagWith: tag ] ]
]

{ #category : 'accessing' }
SEVulnerabilityTagger >> classesImplementing: aString in: aModel [

	^ (self nonTestClassesOf: aModel) select: [ :class |
		  class directImplementedInterfaces anySatisfy: [ :interface |
			  interface ifNil: [ false ] ifNotNil: [ interface name = aString ] ] ]
]

{ #category : 'accessing' }
SEVulnerabilityTagger >> classesOf: aModel [ 
	^ aModel allModelClasses 
]

{ #category : 'accessing' }
SEVulnerabilityTagger >> methodsNamed: aString in: aModel [

	^ aModel allModelMethods select: [ :method |
		  method name = aString ]
]

{ #category : 'accessing' }
SEVulnerabilityTagger >> nonTestClassesOf: aModel [

	^ (self classesOf: aModel) reject: #isTestCase
]

{ #category : 'accessing' }
SEVulnerabilityTagger >> queryBlock [

	^ queryBlock
]

{ #category : 'accessing' }
SEVulnerabilityTagger >> queryBlock: anObject [

	queryBlock := anObject
]

{ #category : 'accessing' }
SEVulnerabilityTagger >> tagName [

	^ self class tagName
]

{ #category : 'instance creation' }
SEVulnerabilityTagger >> tagToUseFrom: aModel [

	^ aModel allTags
		  detect: [ :t | t name = self tagName ]
		  ifNone: [
			  (aModel createTagNamed: self tagName)
				  color: self class tagColor;
				  yourself ]
]
